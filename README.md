# WXT + React Extension Template

This template is primarily based on the [WXT](https://wxt.dev/) web extension framework, which uses a combination of [Vite](https://vite.dev/) and [Web-Ext](https://github.com/mozilla/web-ext) under the hood for testing, packaging, and supporting CI/CD.

WXT is an opinionated framework, so consulting [the documentation](https://wxt.dev/guide/introduction.html) is necessary for understanding how to develop with it.

This template aims to be a completely browser-agnostic starting point.

## Getting Started

After cloning the template, install the package dependencies with

```sh
pnpm i
```

In order to get the development browser auto-launch feature working, some manual setup is required.

The `web-ext.config.ts` file needs to have the paths to local chrome and firefox development browsers specified in order for the `pnpm run dev` and `pnpm run dev:firefox` commands to work. These can be the existing binaries on your device, but it is recommended to install the browser binaries specifically for this project for more control. Note that for chrome versions after 137.x, you MUST use a ["Chrome-For-Testing" version of chrome for any of the automation to work](https://wxt.dev/guide/essentials/config/browser-startup.html#browser-startup).

The template provides a script `install-browsers` to simplify things.

```sh
pnpm run install-browsers
```

Running this command will create two new directories in the root folder and produce an output like this:

```txt
Downloading firefox stable - 131.9 MB [====================] 100% 0.0s
firefox@stable_138.0.4 /Users/me/project-name/firefox/mac_arm-stable_138.0.4/Firefox.app/Contents/MacOS/firefox

Downloading chrome stable - 159.6 MB [====================] 100% 0.0s
chrome@136.0.7103.113 /Users/me/project-name/chrome/mac_arm-136.0.7103.113/chrome-mac-arm64/Google Chrome for Testing.app/Contents/MacOS/Google Chrome for Testing
```

The paths output by the install command can be placed into the web-ext.config.ts file

```ts web-ext.config.ts
import { defineWebExtConfig } from 'wxt';

export default defineWebExtConfig({
  // IMPORTANT: install the puppeteer browser binaries and specify the paths here for development
  binaries: {
    chrome: '/Users/me/project-name/chrome/mac_arm-136.0.7103.113/chrome-mac-arm64/Google Chrome for Testing.app/Contents/MacOS/Google Chrome for Testing',
    firefox: '/Users/me/project-name/firefox/mac_arm-stable_138.0.4/Firefox.app/Contents/MacOS/firefox',
  },
});
```

and then the dev commands will work

```sh
pnpm run dev
```

Note: building a more comprehensive testing suite based on docker or nix is highly recommended for better reproducibility in any production-ready project, but the details of such an implementation are considered out-of-scope for this template.

## Project Structure

The following is a summary of important points for using this template, adapted from the WXT documentation to suit this template's context.

WXT follows a strict project structure. By default, it's a flat folder structure that recognizes the following named directories and configuration files:

```text
 {rootDir}/
   ğŸ“ .output/
   ğŸ“ .wxt/
   ğŸ“ assets/
   ğŸ“ components/
   ğŸ“ composables/
   ğŸ“ entrypoints/
   ğŸ“ hooks/
   ğŸ“ modules/
   ğŸ“ public/
   ğŸ“ utils/
   ğŸ“„ .env
   ğŸ“„ .env.publish
   ğŸ“„ app.config.ts
   ğŸ“„ package.json
   ğŸ“„ tsconfig.json
   ğŸ“„ web-ext.config.ts
   ğŸ“„ wxt.config.ts
```

Here's a brief summary of each of these files and directories:

- `.output/`: All build artifacts will go here
- `.wxt/`: Generated by WXT, it contains TS config
- `assets/`: Contains all CSS, images, and other assets that should be processed by WXT
- `components/`: Auto-imported by default, contains UI components
- `composables/`: (Vue-specific) Auto-imported by default, contains your project's composable functions for Vue
- `entrypoints/`: Contains all the entrypoints that get bundled into your extension
- `hooks/`: Auto-imported by default, contains source code for your project's hooks for React and Solid
- `modules/`: Contains local WXT Modules for your project
- `public/`: Contains any files you want to copy into the output folder as-is, without being processed by WXT
- `utils/`: Auto-imported by default, contains generic utilities used throughout your project
- `.env`: Contains Environment Variables
- `.env.publish`: Contains Environment Variables for publishing
- `app.config.ts`: Contains Runtime Config
- `package.json`: The standard file used by your package manager
- `tsconfig.json`: Config telling TypeScript how to behave
- `web-ext.config.ts`: Config for the development-mode browser auto-startup
- `wxt.config.ts`: The main config file for WXT projects

## Entrypoints

WXT uses the files inside the `entrypoints/` directory as inputs when bundling the extension. They can be HTML, JS, CSS, or any variant of those file types supported by Vite (TS, JSX, SCSS, etc).

### Folder Structure

Inside the `entrypoints/` directory, an entrypoint is defined as a single file or directory (with an index file) inside it.

```text
ğŸ“‚ entrypoints/
   ğŸ“‚ {name}/
      ğŸ“„ index.{ext}
```

Following the entrypoint pattern of named directories with index files makes it easier to adhere to domain-driven development, and so is the pattern endorsed by this project.

For example, the core of this template includes entrypoints for:

- a background(page or service worker)
- a popup page
- a singular content script
- a welcome page (triggered on-download).

The [background](https://wxt.dev/guide/essentials/entrypoints.html#background), [popup](https://wxt.dev/guide/essentials/entrypoints.html#popup), and [content script](https://wxt.dev/guide/essentials/entrypoints.html#content-scripts) entrypoints are considered to be "canonical" to web extensions and are automatically recognized and treated with specific meaning by the WXT framework (among others).

The welcome-page entry point is what the framework calls an ["unlisted page" entrypoint](https://wxt.dev/guide/essentials/entrypoints.html#unlisted-entrypoints). This is a construct of the framework that must be used to create any build artifacts that need to be available by name at runtime. Examples of this are scripts that you wish to execute via `browser.scripting.executeScript()`, or pages to be created via `browser.tabs.create()` (which is how the welcome-page works).

There is more to generic script injection besides this, so see the [Scripting](https://wxt.dev/guide/essentials/scripting.html) section for more.

## Vite Plugins

WXT is a Vite-based framework, and as such, can [make use of Vite plugins.](https://wxt.dev/guide/essentials/config/vite.html)

The only quirk is that instead of using a `vite.config.ts` file, the vite configuration is done inside of `wxt.config.ts` under the `vite` field.

Most Vite plugins should work out of the box with little configuration, but some might require slight tweaks to get them to work with WXT's build system. See the Docs for more information.

## Assets and Public

### Assets

The contents of the assets directory wil be processed by the bundler at build time and during development, creating compiled artifacts that can be referenced by their source code file path from other locations in the project.

For example, the main css file for tailwind, source images that need to be optimized in the build process, code snippets that you wish to statically render into html, wasm files that need special loading logic, etc.

If you have an assets folder like this:

```text
ğŸ“‚ assets/
   ğŸ“„ tailwind.css
```

then you can import the file directly elsewhere in the project (other than content scripts) like this:

```ts
import '~/assets/tailwind.css'
```

or in an html file:

```html
<link rel="stylesheet" href="~/assets/tailwind.css" />
```

#### Assets in Content Scripts

Assets inside content scripts are a little different. By default, when you import an asset, it returns just the path to the asset. This is because Vite assumes you're loading assets from the same hostname.

But, inside content scripts, the hostname is whatever the tab is set to. So if you try to fetch the asset, manually or as an `<img>`'s src, it will be loaded from the tab's website, not your extension.

To fix this, you need to convert the image to a full URL using `browser.runtime.getURL`

hypothetical example content script:

```ts
import iconUrl from '/icon/128.png';

export default defineContentScript({
  matches: ['*://*.google.com/*'],
  main() {
    console.log(iconUrl); // "/icon/128.png"
    console.log(browser.runtime.getURL(iconUrl)); // "chrome-extension://<id>/icon/128.png"
  },
});
```

### Public

Files inside `/public/*` are copied into the output folder as-is, without being processed by WXT's bundler.

To reliably import these assets across versions and browser types, you can import the public files into the source files that need them with the usual import statement to get a URL that will reflect their build-output location, and then use that to access them:

> Warning: public files are not accessible to content scripts by default. You must add them to the manifest `web-accessible-resources` field in `wxt.config.ts` to make them accessible. Once they are accessible, importing them works the same way as for assets in content scripts (above)

[See the documentation for examples](https://wxt.dev/guide/essentials/assets.html#public-directory), as well as information on handling wasm.

## Manifest

WXT does not have a single manifest configuration. Instead, The final manifest output is composed at build-time from a combination of the wxt.config.ts settings, the entrypoint definition functions, the package.json, and settings specific to the desired build targets (manifest v3 vs v2, browser-specific APIs, etc).

The closest thing to a classic manifest file for WXT is the `manifest` key in `wxt.config.ts`, which is generally used to set up global or default manifest options like storage permissions. [Read more about it here](https://wxt.dev/guide/essentials/config/manifest.html).

In general, all manifest options should be specified in their mv3 format, and mv2-compatible versions will be generated as-needed during compilation.

## WebExt Permissions Toggle

This template leverages the [`webext-permissions-toggle`](https://github.com/fregante/webext-permission-toggle) package to enable users to dynamically allow content script access to domains, removing the need to request extensive permissions up-front.

It works alongside the [`webext-dynamic-content-scripts`](https://github.com/fregante/webext-dynamic-content-scripts) package, which simply causes content scripts to re-evaluate their `run-on` condition when the user updates their allowed domains permissions with the permissions toggle.

[A simple explanation can be found here.](https://github.com/fregante/webext-dynamic-content-scripts/blob/main/how-to-add-github-enterprise-support-to-web-extensions.md)

The combination of these two scripts also requires manifest permissions for scripting, storage, activeTab, and contextMenus, and the ability to ask the user for additional optional permissions.

Example manifest fields that cover the required settings for this feature:

```ts
/** wxt.config.ts */

export default defineConfig({
  // ...
  manifest: {
    optional_host_permissions: ['*://*/*',], // for chrome/mv3
    optional_permissions: ['*://*/*'], // for firefox/mv2
    permissions: [
      'storage',
      'scripting',
      'contextMenus',
      'activeTab',
    ],
    action: {},
    // ...
  },
  // ...
})
```

### development quirks

When running the WXT development server, content scripts may not be listed properly in the manifest at all times due to HMR and dynamic builds. This is a problem for using webext-permissions-toggle, as it will cause `addPermissionToggle();` to fail and throw an error in the background (luckily with a good error message).

To work around this for development, we need to add a WXT hook to the config that defines the manifest entries for our scripts statically on the initial build of the manifest during development.

so for a script at `entrypoints/content/index.ts` with `matches: ['*://*.google.com/*'],`, we would need to add this to the `hooks` field of `wxt.config.ts`:

```ts
/** wxt.config.ts */

export default defineConfig({
  // ...
  hooks: {
    'build:manifestGenerated': (wxt, manifest) => {
      if (wxt.config.command === 'serve') {
        manifest.content_scripts ??= [];
        manifest.content_scripts.push({
          matches: ['*://*.google.com/*'],
          js: ['/content-scripts/content.js'],
          // If the script has CSS, add it here.
        });
      }
    },
  },
  // ...
})
```

And if we added another content script at `entrypoints/another.content/index.tsx` with `matches: ['*://*.wxt.dev/*'],`, we would need to add this to the `hooks` field of `wxt.config.ts`:

```ts
/** wxt.config.ts */

export default defineConfig({
  // ...
  hooks: {
    'build:manifestGenerated': (wxt, manifest) => {
      if (wxt.config.command === 'serve') {
        manifest.content_scripts ??= [];
        manifest.content_scripts.push({
          matches: ['*://*.google.com/*'],
          js: ['/content-scripts/content.js'],
          // If the script has CSS, add it here.
        });
        manifest.content_scripts.push({
          matches: ['*://*.wxt.dev/*'],
          js: ['/content-scripts/another.js'],
          // If the script has CSS, add it here.
        });
      }
    },
  },
  // ...
})
```

Note that these will be overridden in the manifest by the actual settings in the routes, so you do not need to mirror all of [the manifest fields that content scripts can specify](https://wxt.dev/guide/essentials/entrypoints.html#content-scripts) from the entrypoint routes - just the `matches` field and the name of the output file.
